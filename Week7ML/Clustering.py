from sklearn.preprocessing import StandardScaler
from sklearn.cluster import KMeans
import utils
import pandas as pd
import numpy as np
from itertools import cycle, islice
import matplotlib.pyplot as plt
'''
 FutureWarning: 'pandas.tools.plotting.parallel_coordinates' is deprecated, import 'pandas.plotting.parallel_coordinates' instead.
'''
from pandas.plotting import parallel_coordinates


#%matplotlib inline

#creating a dataframe
data = pd.read_csv('C:\\Users\\yanlu\\Documents\\Data Science\\Week-7-MachineLearning\\Week-7-MachineLearning\\weather\\minute_weather.csv')
data.shape
#print(data.head())
#Data Sampling sample down by taking every 10th row
sampled_df = data[(data['rowID'] % 10) == 0]
sampled_df.shape

#.transpose() turns the cols into rows   vice versa
sampled_df.describe().transpose()
#select rain_accumulation == 0 from sampled_df
sampled_df[sampled_df['rain_accumulation'] == 0].shape
sampled_df[sampled_df['rain_duration'] == 0].shape

#Drop all the rows with Empty rain _duration and rain_accumulation
del sampled_df['rain_accumulation']
del sampled_df['rain_duration']

rows_before = sampled_df.shape[0]
sampled_df = sampled_df.dropna()
rows_after = sampled_df.shape[0]

print(rows_before - rows_after)
#what cols are left
print(sampled_df.columns)
# Select Features of Interest for clustering
features = ['air_pressure', 'air_temp', 'avg_wind_direction', 'avg_wind_speed', 'max_wind_direction',
        'max_wind_speed','relative_humidity']
select_df = sampled_df[features]
select_df.columns
select_df
#Scale features using standardscaler
#fit_transform combines fit and transform,
'''
1. first calculates how much data set should be transformed to be scaled -> it looks at diff values and finds how to scale it.
'''
X = StandardScaler().fit_transform(select_df)
X
#Use k-Means Clustering
kmeans = KMeans(n_clusters=12)
model = kmeans.fit(X) #-> K-Means object
print("model\n", model)

#Centers of 12 clusters
centers = model.cluster_centers_
centers

#it takes cluster centers generated by model

def pd_centers(featuresUsed, centers):
	colNames = list(featuresUsed)
	colNames.append('prediction')

	# Zip with a column called 'prediction' (index)
	Z = [np.append(A, index) for index, A in enumerate(centers)]

	# Convert to pandas data frame for plotting
	P = pd.DataFrame(Z, columns=colNames)
	P['prediction'] = P['prediction'].astype(int)
	return P
# Function that creates Parallel Plots
def parallel_plot(data):
	my_colors = list(islice(cycle(['b', 'r', 'g', 'y', 'k']), None, len(data)))
	plt.figure(figsize=(15,8)).gca().axes.set_ylim([-3,+3])
	parallel_coordinates(data, 'prediction', color = my_colors, marker='o')
P = pd_centers(features, centers)
P
#dry days
'''
x axix each of the seven features
y axis value of each cluster center
'''
parallel_plot(P[P['relative_humidity'] < -0.5])

#warm day
parallel_plot(P[P['air_temp'] > 0.5])
#cool day
parallel_plot(P[(P['relative_humidity'] > 0.5) & (P['air_temp'] < 0.5)])